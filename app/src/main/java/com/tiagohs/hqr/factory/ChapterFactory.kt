package com.tiagohs.hqr.factory

import com.tiagohs.hqr.models.database.comics.Chapter
import com.tiagohs.hqr.models.database.comics.Comic // Keep for comic reference, but not for Realm instance
import com.tiagohs.hqr.models.view_models.ChapterViewModel
// Removed: import io.realm.Realm
// Removed: import io.realm.RealmList
// Removed: import com.tiagohs.hqr.helpers.tools.RealmUtils (Realm interaction removed)

object ChapterFactory {

    /**
     * Creates a new (detached) Chapter RealmObject from a ChapterViewModel and a Comic RealmObject reference.
     * The comic reference is for linking; it's assumed to be a managed or unmanaged Realm object
     * that will be correctly handled by the repository during persistence.
     * ID generation is simplified; repository should handle assigning new IDs if needed.
     */
    fun createChapterFromViewModel(chapterViewModel: ChapterViewModel, comicReference: Comic? /* This Comic is the new RealmObject type */, skipDownloaded: Boolean = false): Chapter {
        return Chapter().apply {
            // If chapterViewModel.id is -1L, a new ID should be generated by the repository or a UUID.
            // For now, we just assign it. Repositories using UpdatePolicy.ALL will update if exists, or insert if new.
            this.id = chapterViewModel.id 
            this.chapterName = chapterViewModel.chapterName
            this.chapterPath = chapterViewModel.chapterPath
            this.lastPageRead = chapterViewModel.lastPageRead
            if (!skipDownloaded) {
                this.downloaded = chapterViewModel.downloaded
            }
            this.comic = comicReference // Assign the new Comic RealmObject reference
        }
    }

    /**
     * Updates an existing (detached or managed) Chapter RealmObject from a ChapterViewModel.
     * The comic reference is for linking.
     */
    fun updateChapterFromViewModel(existingChapter: Chapter, chapterViewModel: ChapterViewModel, comicReference: Comic?, skipDownloaded: Boolean = false): Chapter {
        existingChapter.chapterName = chapterViewModel.chapterName ?: existingChapter.chapterName
        existingChapter.chapterPath = chapterViewModel.chapterPath ?: existingChapter.chapterPath
        if (chapterViewModel.lastPageRead != -1) { // Assuming -1 means "not set"
            existingChapter.lastPageRead = chapterViewModel.lastPageRead
        }
        if (!skipDownloaded) {
            existingChapter.downloaded = chapterViewModel.downloaded
        }
        existingChapter.comic = comicReference // Update comic reference if necessary
        return existingChapter
    }

    /**
     * Maps a list of ChapterViewModel objects to a list of new (detached) Chapter RealmObjects.
     * This is a simple mapping; repository will handle persistence and linking.
     */
    fun createChapterListFromViewModelList(viewModels: List<ChapterViewModel>?, comicReference: Comic?): List<Chapter> {
        if (viewModels == null) return emptyList()
        return viewModels.map { viewModel ->
            createChapterFromViewModel(viewModel, comicReference)
        }
    }

    /**
     * Maps a list of Chapter RealmObjects (assumed detached or managed) to a list of ChapterViewModels.
     * Relies on ChapterViewModel's own mapping logic (e.g., a constructor or an init method).
     */
    fun createListOfChapterViewModel(chapters: List<Chapter>): List<ChapterViewModel> {
        return chapters.map { chapterRealmObject ->
            ChapterViewModel().create(chapterRealmObject) // Assuming ChapterViewModel has a 'create' or similar method
        }
    }

}